# This script contains the encapsulated methods,
# responsible for the processing required to get the output as mentioned in the assignment.
from queue import Queue

class Node:
    def __init__(self, data, left = None, right = None):
        self.data = data
        self.left = left
        self.right = right

#Method to create a Tree from a given array
def createTree(array):
    """
    Arguments:
    array: Array to be converted to the Binary tree.
    """

    """
    Variables:
    dictionary = Dictionary to hold the node number and its respective memory address for faster access.
    root = represents root node of binary tree
    """
 
    # create an empty dict
    #Since, we need to delete node based on node number and not by matching data present at that node,
    #we need to assign each memory address a key value to access that target node later.
    dictionary = {}
 
    # create n tree nodes each having value from 0 to n-1
    # and store them in a dict
    for i in range(len(array)):
        dictionary[i] = Node(i)

    root = None
 
    # traverse the array list and build the tree
    for i, e in enumerate(array):
 
        # if array is -1, set root to current node having
        # value i (stored in dict[i])
        if e == -1:
            root = dictionary[i]
        else:
            # get array node for current node
            ptr = dictionary[e]
 
            # if array's left child is filled, dict the node to its right child
            if ptr.left:
                ptr.right = dictionary[i]
            # if array's left child is empty, dict the node to it
            else:
                ptr.left = dictionary[i]
 
    # return root of the constructed tree
    return root, dictionary

#Method to return the number of leaf nodes in a given tree
def getCount(node):
    """
    Arguments:
    node = the memory address of the node from which the counting of leaf nodes to be started. 
    """
    if not node:
        return 0
    #Since there is a possibility of the original array to be large.
    #Tree Travesal and leaf node counting functionality is implemented using a Queue instead of an array.    
    q = Queue()

    #Initialize the leaf node cout as 0.
    count = 0

    #add the root node to the Queue.
    q.put(node)
    while (not q.empty()):
        tmp = q.queue[0]

        #get() method is included in the Queue module. 
        #Remove and return an item from the queue.
        q.get()

        #if left child of tmp is not empty, add it to the Queue.
        if (tmp.left != None):
            q.put(tmp.left)
        
        #if right child of tmp is not empty, add it to the Queue.
        if (tmp.right != None):
            q.put(tmp.right)

        #if the node tmp has no child(bith child are set as None),
        #It means tmp is leaf node.
        #Increment count by 1
        if (tmp.left != None and tmp.right != None):
            count += 1
    return count

#Method to delete the sub tree formed by the data_node
def deleteSubTree(data_node):
    """
    Arguments:
    data_node = the memory address of the target node
    """
    #Return None if data_node is empty.
    if not data_node:
        return
    
    #if data node does not have any child,
    #return None as no left or right child are to be deleted
    if (not data_node.left) and (not data_node.right):
        return
    
    #set left child of the target node to None(delete all subsequent nodes)
    data_node.left = deleteSubTree(data_node.left)

    #set right child of the target node to None(delete all subsequent nodes)
    data_node.right = deleteSubTree(data_node.right)
    
    #set the target node to none
    data_node = None


def processWrapper(Array, target):
    """
    Function arguments:
    A = An array storing n integers (values of the nodes of the Binary tree).
    target = The data node to be deleted. 
            0 for root node, 
            1 for left child at level 1 Left Node, 
            2 for level 2 right node, so on.
    """
    
    """
    Variables:

    root = the pointer to the root of the Binary Tree. Generated by createTree() method.
    
    dictionary = A dictionary in the format {"Node number": "Node memory location"}, to enable direct access to nodes.
    
    data_node = the memory location of the target node.
    """
    #Create a binary tree using the array passed as the argument
    root, dictionary = createTree(Array)
    
    #get the memory location of the node to be deleted. For faster deletion process.
    data_node = dictionary[target]

    #Call the deleteSubTree() method to delete the Sub-tree formed by the target node.
    deleteSubTree(data_node)

    #Print the total number of leaf nodes remaining after the deletion process is completed.
    print(getCount(root))

    


